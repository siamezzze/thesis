% В этом файле следует писать текст работы, разбивая его на
% разделы (section), подразделы (subsection) и, если нужно,
% главы (chapter).

% Предварительно следует указать необходимую информацию
% в файле SETUP.tex

\input{preamble.tex}

\begin{document}
\Task
Необходимо реализовать алгоритм для поиска аналитических кривых — в частности, эллипсов — на изображении.
При этом алгоритм должен быть устойчивым к шуму и работать в реальном времени.
Никакие параметры эллипса заранее не известны.

\Intro

Поиск аналитических кривых на изображении является важной задачей компьютерного зрения и смежных областей. Выделение областей, заданных такими кривыми, помогает в распознавании более сложных фигур.

Преобразование Хафа - алгоритм, часто использующийся для поиска объектов, принадлежащих классу заранее заданных фигур. 
Поиск объектов проходит при помощи процедуры голосования - каждая точка контура "голосует" за объект с теми параметрами, которым она может принадлежать. 
Изначально алгоритм использовался для поиска линий, затем он был обобщен для поиска кривых ~\autocite{Duda}.
Преобразование Хафа является распространенным инструментом для поиска объектов на изображении, но становится все более затратным по времени и памяти с увеличением количества параметров в уравнении кривой.

Одним из способов уменьшить затраты по времени и памяти является иерархический подход, в котором поиск производится на изображении небольшого размера, а затем полученные параметры уточняются. 
Другой модификацией алгоритма явлеяется снижение затрат по памяти за счет использования некоторых соотношений между параметрами эллипса.
В настоящей работе эти два подхода соединены для достижения наибольшей экономии по времени и памяти.

Предполагается, что дано изображение достаточно большого размера, на котором требуется найти один или несколько эллипсов, определив их параметры: 
координаты центра \((x, y)\), длины большой и малой полуосей \(a\) и \(b\), а также поворот. Предплагается, что все эллипсы, если они есть, лежат 
полностью внутри изображения. При этом не обязательно, чтобы эллипс был представлен целиком - его контур может прерываться или перекрываться. 
Однако требуется, чтобы краевые точки эллипса на изображении были представлены, так как именно по ним ведется поиск.  

Алгоритм работает как для изображений в оттенках серого, так и для цвеных изображений.

\section{Исследование предметной области}
Существуют различные подходы к проблеме поиска эллипсов на изображении.  Большинство из них являются модификациями алгоритма Хафа, но испльзовались и такие подходы, как группировка контуров и генетические алгоритмы.

Один из первых алгоритмов, обобщающих преобразование Хафа на аналитические кривые, был предложен в работе ~\autocite{Ballard}, однако для него требуется заранее знать отклонения искомого объекта (сжатие, поворот) относительно канонической формы, либо перебирать все варианты, что является затратным по времени и памяти.

Алгоритм, предложенный в работе ~\autocite{OneDim} позволяет уменьшить затраты по памяти - в качестве аккумулирующего массива используется одномерный массив, хранящий возможные длины малого радиуса.

В работе ~\autocite{Chien} авторы предложили алгоритм, заметно ускоряющий поиск за счет использования пирамидальной структуры данных для изображения. 
олный поиск проводится только на вершине пирамиды, что значительно снижает затраты по времени.

\section{Описание алгоритма}
Алгоритм для поиска одного эллипса описывается схемой, представленной на рисунке 1. 
Сначала поиск проводится на уменьшенном изображении, затем параметры итеративно уточняются путем поиска на изображениях большего размера.
\begin{figure}
\centering
\includegraphics[width=0.7\textwidth]{img/oneellipse.png}
\caption{\label{fig:oneellipse} Общая схема алгоритма поиска одного эллипса}
\end{figure}
\subsection{Подготовка изображения}
Проводится выделение краев (использовался алгоритм Кэнни). Также можно использовать размывание для уменьшения количества шума.
\subsection{Создание иерархической пирамиды}
Создаются уменьшенные копии изображения с выделенными краями следующим образом:
\begin{enumerate}
  \item Изображение преобразуется к квадратному NxN, где N - степень числа 2.
  \item Изображение переводится в матрицу со значениями 0-1, где 0 означает, что пиксел на этой позиции не является краевым, 1 - что является.

\begin{lstlisting}
    pyramid[0] = vector<vector<short> >(max_size,vector<short>(max_size,0)); //creating the first image (original size)
    for (int i = 0; i < max_size; ++i) {
        for (int j = 0; j < max_size; ++j) {
            uchar p = resized.at<uchar>(i,j);
            if (p > 0)
                pyramid[0][i][j] = 1;
        }
    }

\end{lstlisting}

\item Итеративно вычисляются матрицы меньших размеров: N уменьшается в 2 раза, причем значение каждой ячейки вычисляется как сумма значений четырёх соответствующих ячеек матрицы, полученной на предыдущем этапе.
\end{enumerate}
Процесс продолжается до тех пор, пока не будет достигнуто минимальное разрешение, заданное заранее. Большее разрешение дает большую точность, но увеличивает затраты времени, памяти и влияние шума. В опытах было использовано разрешение 64х64.

\begin{lstlisting}
//create next levels by summing up pixels of previous ones.
for (int i = 1; i < steps; i++)
{
    sz /= 2;
    pyramid[i] = vector<vector<short> >(sz,vector<short>(sz,0));
    for (int j = 0; j < sz; j++)
    {
        for (int k = 0; k < sz; ++k) {
            pyramid[i][j][k] = pyramid[i-1][j*2][k*2] + pyramid[i-1][j*2+1][k*2] + pyramid[i-1][j*2][k*2+1] + pyramid[i-1][j*2+1][k*2+1];
        }
    }
}
\end{lstlisting}
\subsection{Первичный поиск}
Первичный поиск проводится модифицированным по памяти алгоритмом Хафа для матрицы минимального размера.
Модификация по памяти заключается в том, что вместо трехмерного аккумуляторного массива используется одномерный.
Этого можно добиться, используя соотношения между различными параметрами эллипса~\autocite{OneDim}.

Двойным циклом по всем парам точек контуров, найденных на изображении, выбираются и фиксируются две точки \((x_1, y_1)\) и \((x_2, y_2)\) в предположении, что они являются краевыми точками большой оси эллипса.

\begin{lstlisting}
if (((y2 == y1) && (x2 <= x1)) || (data[y2][x2] == 0)) //already been selected OR not a boundary point
    continue;
\end{lstlisting}

На этом этапе вычисляются параметры эллипса по следующим формулам:

\(x_0 = (x_1 + x_2)/2\)

\(y_0 = (y_1 + y_2)/2\)

\(a = [(x_2 - x_1)^2 + (y_2 - y_1)^2]^{1/2} / 2 \)

\(\theta = atan [(y_2 - y_1) / (x_2 - x_1)] \)

Здесь \(a\) - большая полуось предпологаемого эллипса, \((x_0, y_0)\) - его центр, а \(\theta\) - поворот относительно оси \(Ox\).

\begin{lstlisting}
pair<int, int> center = compute_center(x1, y1, x2, y2); //get the center point of the ellipse
int x0 = center.first;
int y0 = center.second;

double a_sq = major_axis_length_sq(x1, y1, x2, y2);
double a = sqrt(a_sq); //half of the major axis
double orient = orientation(x1, y1, x2, y2); //rotation of the ellipse
\end{lstlisting}

Затем циклом по всем точкам контуров перебираются все точки, которые могут принадлежать эллипсу - то есть, лежат не слишком близко к оси (не меньше заранее заданного параметра \(min\_dist\)), 
что исключает ошибочное определение прямой, как эллипса, и не дальше длины большой полуоси от центра.

\begin{lstlisting}
if (((x == x1) && (y == y1)) ||
    ((x == x2) && (y == y2)) ||
    (data[y][x] == 0)) //the same as one of the side points or not a boundary point
        continue;
double d_sq = distance_square(x, y, x0, y0);
double d = sqrt(d_sq); //distance from the center
if ((d < min_dist) || (d > a))
    continue;
\end{lstlisting}

Для всех таких точек вычисляется длина малой полуоси \(b\) из следующего равенста:

\(b^2 = (a^2d^2sin^2\tau)/(a^2-d^2cos^2\tau) \)

Здесь \(\tau\) - угол между большой полуосью и отрезком, соединяющим центр эллипса \((x_0, y_0)\) с точкой \((x, y)\). Он определяется равенством

\(cos\tau = (a^2 + d^2 - f^2)/(2ad)\).

В аккумуляторном массиве значение, соответствующее этой длине, увеличивается.
\begin{lstlisting}
double f_sq = min(distance_square(x, y, x1, y1),
               distance_square(x, y, x2, y2)); //distance to the nearest side point
double costau = (a_sq + d_sq - f_sq) / (2 * a * d);
double costau_sq = costau * costau;
double sintau_sq = 1 - costau_sq;
double b_sq = (a_sq * d_sq * sintau_sq) / (a_sq - d_sq * costau_sq);
int b = cvRound(sqrt(b_sq));
if (b > min_dist) { //voting
    acc[b] += data[y][x];
}
\end{lstlisting}

После того, как все возможные точки эллипса были обработаны, в аккумуляторном массиве находится максимальный элемент. 
Значение длины малой полуоси, соответствующее ему, заносится вместе с остальными параметрами эллипса и количеством полученных голосов в список кандидатов.
\begin{lstlisting}
int maxlength = 0;
int maxvote = 0;
for (int k = 0; k < maxlen; ++k) {
    if (acc[k] >= maxvote)
    {
        maxvote = acc[k];
        maxlength = k;
    }
    acc[k] = 0;
}
if (maxvote > min_vote )
{
    res.push_back(make_pair(ellipse_data(x0,y0, a, maxlength, orient, x1, y1, x2, y2),maxvote));
}
\end{lstlisting}

После обработки всех возможных пар краевых точек из списка эллипсов-кандидатов выбирается один, имеющий наибольшее количество голосов - он и считается найденным эллипсом.

\subsection{Уточнение}
Уточнение параметров эллипса проходит итеративно с постепенным увеличением разрешения.
На каждом этапе проводится поиск, схожий с первичным, но области, в которых идет перебор возможных краевых точек, ограничен.
Если \((x, y)\) - координаты первой краевой точки эллипса, найденного на предыдущем шаге, то поиск новой точки следует 
проводить в квадрате \((2x - 1, 2y - 1), (2x + 1, 2y - 1), (2x + 1, 2y + 1), (2x - 1, 2y + 1)\). В остальном алгоритм остается тем же, что и для первичного поиска.

\subsection{Поиск нескольких эллипсов}

Если на изображении представлено несколько эллипсов, то последовательными применениями описанного выше алгоритма можно найти их все. 
Для этого после определения очередного эллипса нужно в изображении с выделенными краями обнулить все точки, принадлежащие эллипсу, после чего запустить алгоритм снова.

\begin{lstlisting}
for (int i = 0; i < number_of_ellipses; i++)
{
    ellipse_data elp = ellipse_detection(edges, minimized_size, 5, 9);
    ellipses[i] = elp;
    clear_picture(edges, elp);
}
return ellipses;
\end{lstlisting}

\section{Результаты}
В процессе работы была создана программная реализация на языке C++ (использовался компилятор g++ версии 4.9.2). 
Для загрузки изображения, сохранения результатов, а также первичной обработки (выделения границ) использовалась библиотека OpenCV версии 3.0.

Для оценки работы программы использовались как синтетические, так и реальные изображения размеров 256x256, 512х512, 1024x1024 с различным количеством объектов для поиска и разной степенью зашумления.

\begin{figure}
\centering
\caption{\label{tab:results}Некоторые результаты}
\begin{tabular}{| l | l |}
  \hline 
  Исходное изображение & Результат \\
  \hline 
  &\\
  \includegraphics[width=0.4\textwidth]{img/s20.jpg} & \includegraphics[width=0.4\textwidth]{img/s20r.jpg} \\
  \hline 
  &\\
  \includegraphics[width=0.4\textwidth]{img/s18.jpg} & \includegraphics[width=0.4\textwidth]{img/s18r.jpg} \\
  \hline 
  &\\
  \includegraphics[width=0.4\textwidth]{img/s29.jpg} & \includegraphics[width=0.4\textwidth]{img/s29r.jpg} \\
  \hline 
\end{tabular}
\end{figure}

\section{Анализ алгоритма}
\subsection{Затраты по времени и памяти}
\subsection{Точность определения}
\subsection{Устойчивость к шуму}


\Conc



% Печать списка литературы (библиографии)
\printbibliography[heading=bibintoc%
    %,title=Библиография % если хочется это слово
]
% Файл со списком литературы: biblio.bib
% Подробно по оформлению библиографии:
% см. документацию к пакету biblatex-gost
% http://ctan.mirrorcatalogs.com/macros/latex/exptl/biblatex-contrib/biblatex-gost/doc/biblatex-gost.pdf
% и огромное количество примеров там же:
% http://mirror.macomnet.net/pub/CTAN/macros/latex/contrib/biblatex-contrib/biblatex-gost/doc/biblatex-gost-examples.pdf

\end{document}
