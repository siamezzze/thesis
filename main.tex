% В этом файле следует писать текст работы, разбивая его на
% разделы (section), подразделы (subsection) и, если нужно,
% главы (chapter).

% Предварительно следует указать необходимую информацию
% в файле SETUP.tex

\input{preamble.tex}

\begin{document}
\Task
\begin{enumerate}
  \item
Разработать алгоритм для поиска эллипсов на изображении.
  \item
Реализовать разработанный алгоритм.
  \item
Протестировать работу полученной программы.
\end{enumerate}
\Intro
Поиск аналитических кривых на изображении является важной задачей компьютерного зрения и смежных областей. Выделение областей, заданных такими кривыми, помогает в распознавании более сложных фигур.

Преобразование Хафа - алгоритм, часто использующийся для поиска объектов, принадлежащих классу заранее заданных фигур. 
Поиск объектов проходит при помощи процедуры голосования - каждая точка контура "голосует" за объект с теми параметрами, которым она может принадлежать. 
Изначально алгоритм использовался для поиска линий, затем он был обобщен для поиска кривых~\autocite{Duda}.
Преобразование Хафа является распространенным инструментом для поиска объектов на изображении, но становится все более затратным по времени и памяти с увеличением количества параметров в уравнении кривой.

Одним из способов уменьшить затраты по времени и памяти является иерархический подход, в котором поиск производится на изображении небольшого размера, а затем полученные параметры уточняются. 
Другой модификацией алгоритма является снижение затрат по памяти за счет использования некоторых соотношений между параметрами эллипса.
В настоящей работе эти два подхода соединены для достижения наибольшей экономии по времени и памяти.

Предполагается, что дано изображение достаточно большого размера, на котором требуется найти один или несколько эллипсов, определив их параметры: 
координаты центра \((x, y)\), длины большой и малой полуосей \(a\) и \(b\), а также поворот. Предполагается, что все эллипсы, если они есть, лежат 
полностью внутри изображения. При этом не обязательно, чтобы эллипс был представлен целиком - его контур может прерываться или перекрываться. 
Однако требуется, чтобы краевые точки большой оси эллипса на изображении были представлены, так как именно по ним ведется поиск.  

Алгоритм работает как для изображений в оттенках серого, так и для цветных изображений.

\section{Исследование предметной области}
Существуют различные подходы к проблеме поиска эллипсов на изображении.  Большинство из них являются модификациями алгоритма Хафа, 
но испльзовались и такие подходы, как группировка контуров и генетические алгоритмы.

Если использовать для поиска эллипсов ту же стратегию, что и для прямых и окружностей, алгоритм будет описываться приблизительно так (считаем, что изображение имеет размер NxN):
\begin{enumerate}
\item Для каждого ненулевого пиксела изображения (максимум NxN вариантов):
\item Выбирается первый фокус (в предположении, что фокусы расположены на изображении, а не за его пределами - NxN вариантов).
\item Выбирается второй фокус (NxN вариантов).
\item Вычисляется поворот и остальные параметры эллипса.
\item В аккумуляторном массиве значение, соответствующее найденным параметрам (центр, поворот, два радиуса)
\end{enumerate}

Алгоритм в таком виде будет иметь временную сложность \(O(N^6)\), а также потребует хранения 5-мерного аккумуляторного массива. По этим причинам на практике такая реализация не применима.
Чтобы использовать преобразование Хафа для поиска эллипсов, требуется модифицировать его, уменьшив время работы и требуемую память.

Один из первых алгоритмов, обобщающих преобразование Хафа на аналитические кривые, был предложен в работе~\autocite{Ballard}, 
однако для него требуется заранее знать отклонения искомого объекта (сжатие, поворот) относительно канонической формы, либо перебирать все варианты, что также является затратным по времени и памяти.

Алгоритм, предложенный в работе~\autocite{OneDim} позволяет уменьшить затраты по памяти - в качестве аккумулирующего массива используется одномерный массив, хранящий возможные длины малого радиуса.
Временная сложность такого алгоритма составляет \(O(n^3)\), где \(n\) - количество ненулевых пикселов.

В работе~\autocite{Chien} авторы предложили алгоритм, заметно ускоряющий поиск за счет использования пирамидальной структуры данных для изображения. 
Полный поиск проводится только на вершине пирамиды, что значительно снижает затраты по времени.

В данной работе модификации из работ~\autocite{OneDim} и ~\autocite{Chien} объединены для обеспечения наибольшей экономии ресурсов.

\section{Описание алгоритма}
Алгоритм для поиска одного эллипса описывается схемой, представленной на рисунке ~\ref{fig:oneellipse}. 
Общая идея состоит в том, что сначала проводится поиск на уменьшенном изображении, затем параметры найденного эллипса итеративно уточняются путем поиска на изображениях большего размера.
\begin{figure}
\centering
\caption{\label{fig:oneellipse} Общая схема алгоритма поиска одного эллипса}
\includegraphics[width=0.9\textwidth]{img/oneellipse.png}
\end{figure}
\subsection{Подготовка изображения}
Проводится выделение краев (использовался алгоритм Кэнни). Важно отметить, что алгоритм, описанный далее, будет работать тем лучше, чем меньше на изображении шума и ненулевых пикселов,
не принадлежащих искомым эллипсам. От этого зависит как скорость работы, так и точность определения. 
По этой причине очень важно на этапе предобработки отсеять как можно больше информации, не относящейся к эллипсам. Для этих целей можно использовать размывание.
\subsection{Создание иерархической пирамиды}
Создаются уменьшенные копии изображения с выделенными краями следующим образом:
\begin{enumerate}
  \item Изображение преобразуется к квадратному NxN, где N - степень числа 2.
  \item Изображение переводится в матрицу со значениями 0-1, где 0 означает, что пиксел на этой позиции не является краевым, 1 - что является.

\begin{ListingEnv}[H]
\begin{lstlisting}
pyramid[0] = vector<vector<short> >(max_size,vector<short>(max_size,0)); //creating the first image (original size)
for (int i = 0; i < max_size; ++i) {
    for (int j = 0; j < max_size; ++j) {
        uchar p = resized.at<uchar>(i,j);
        if (p > 0)
            pyramid[0][i][j] = 1;
    }
}
\end{lstlisting}
\caption{Создание первого уровня иерархической пирамиды}
\label{list:level0}
\end{ListingEnv}
\item Итеративно вычисляются матрицы меньших размеров: N уменьшается в 2 раза, после чего вычисляется новая матрица. 
При этом значение каждой ячейки вычисляется как сумма значений четырёх соответствующих ячеек матрицы, полученной на предыдущем этапе.

\begin{ListingEnv}[H]
\begin{lstlisting}
for (int i = 1; i < steps; i++)
{
    sz /= 2;
    pyramid[i] = vector<vector<short> >(sz,vector<short>(sz,0));
    for (int j = 0; j < sz; j++)
    {
        for (int k = 0; k < sz; ++k) {
            pyramid[i][j][k] = pyramid[i-1][j*2][k*2] + pyramid[i-1][j*2+1][k*2] + pyramid[i-1][j*2][k*2+1] + pyramid[i-1][j*2+1][k*2+1];
        }
    }
}
\end{lstlisting}
\caption{Создание следующих уровней иерархической пирамиды}
\label{list:otherlevels}
\end{ListingEnv}

\end{enumerate}
Процесс продолжается до тех пор, пока не будет достигнуто минимальное разрешение, заданное заранее. Большее разрешение дает большую точность, но увеличивает затраты времени, памяти и влияние шума.

\subsection{Первичный поиск}
Первичный поиск проводится модифицированным по памяти алгоритмом Хафа для матрицы минимального размера.
Модификация по памяти заключается в том, что вместо трехмерного аккумуляторного массива используется одномерный.
Этого можно добиться, используя соотношения между различными параметрами эллипса~\autocite{OneDim}.

Двойным циклом по всем парам точек контуров, найденных на изображении, выбираются и фиксируются две точки \((x_1, y_1)\) и \((x_2, y_2)\) в предположении, что они являются краевыми точками большой оси эллипса.

\begin{lstlisting}
if (((y2 == y1) && (x2 <= x1)) || (data[y2][x2] == 0)) //already been selected OR not a boundary point
    continue;
\end{lstlisting}

На этом этапе вычисляются параметры эллипса по следующим формулам:
$$x_0 = \frac{x_1 + x_2}{2}$$
$$y_0 = \frac{y_1 + y_2}{2}$$
$$a = \frac{\sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}}{2}$$
$$\theta = atan(\frac{y_2 - y_1}{x_2 - x_1}).$$
Здесь \(a\) - большая полуось предпологаемого эллипса, \((x_0, y_0)\) - его центр, а \(\theta\) - поворот относительно оси \(Ox\).

\begin{ListingEnv}[H]
\begin{lstlisting}
pair<int, int> center = compute_center(x1, y1, x2, y2); //get the center point of the ellipse
int x0 = center.first;
int y0 = center.second;

double a_sq = major_axis_length_sq(x1, y1, x2, y2);
double a = sqrt(a_sq); //half of the major axis
double orient = orientation(x1, y1, x2, y2); //rotation of the ellipse
\end{lstlisting}
\caption{Вычисление параметров эллипса, шаг 1}
\label{list:majoraxis}
\end{ListingEnv}
Затем циклом по всем точкам контуров перебираются все точки \((x,y)\), которые могут принадлежать эллипсу - то есть, лежат не слишком близко к оси (не меньше заранее заданного параметра \(min\_dist\)), 
что исключает ошибочное определение прямой, как эллипса, и не дальше длины большой полуоси от центра.

\begin{lstlisting}
double d = sqrt(distance_square(x, y, x0, y0));
if ((d < min_dist) || (d > a))
    continue;
\end{lstlisting}

Для всех таких точек вычисляется длина малой полуоси \(b\) из следующего равенста:
$$b^2 = \frac{a^2d^2sin^2\tau}{a^2-d^2cos^2\tau}$$
Здесь \(\tau\) - угол между большой полуосью и отрезком, соединяющим центр эллипса \((x_0, y_0)\) с точкой \((x, y)\). Он определяется равенством
$$cos\tau = \frac{a^2 + d^2 - f^2}{2ad}.$$
В аккумуляторном массиве значение, соответствующее этой длине, увеличивается.
\begin{ListingEnv}[H]
\begin{lstlisting}
double f_sq = min(distance_square(x, y, x1, y1),
               distance_square(x, y, x2, y2)); //distance to the nearest side point
double costau = (a_sq + d_sq - f_sq) / (2 * a * d);
double costau_sq = costau * costau;
double sintau_sq = 1 - costau_sq;
double b_sq = (a_sq * d_sq * sintau_sq) / (a_sq - d_sq * costau_sq);
int b = cvRound(sqrt(b_sq));
if (b > min_dist) { //voting
    acc[b] += data[y][x];
}
\end{lstlisting}
\caption{Вычисление параметров эллипса, шаг 2}
\label{list:minoraxis}
\end{ListingEnv}

После того, как все возможные точки эллипса были обработаны, в аккумуляторном массиве находится максимальный элемент. 
Значение длины малой полуоси, соответствующее ему, заносится вместе с остальными параметрами эллипса и количеством полученных голосов в список кандидатов.

После обработки всех возможных пар краевых точек из списка эллипсов-кандидатов выбирается один, имеющий наибольшее количество голосов - он и считается найденным эллипсом.

\subsection{Уточнение}
Уточнение параметров эллипса проходит итеративно с постепенным увеличением разрешения.
На каждом этапе проводится поиск, схожий с первичным, но области, в которых идет перебор возможных краевых точек, ограничен.
Если \((x, y)\) - координаты первой краевой точки эллипса, найденного на предыдущем шаге, то поиск новой точки следует 
проводить в квадрате \((2x - 1, 2y - 1), (2x + 1, 2y - 1), (2x + 1, 2y + 1), (2x - 1, 2y + 1)\). В остальном алгоритм остается тем же, что и для первичного поиска.

\subsection{Поиск нескольких эллипсов}

Если на изображении представлено несколько эллипсов, то последовательными применениями описанного выше алгоритма можно найти их все. 
Для этого после определения очередного эллипса нужно в изображении с выделенными краями обнулить все точки, принадлежащие эллипсу, после чего запустить алгоритм снова.

\begin{ListingEnv}[H]
\begin{lstlisting}
for (int i = 0; i < number_of_ellipses; i++)
{
    ellipse_data elp = ellipse_detection(edges, minimized_size, 5, 9);
    ellipses[i] = elp;
    clear_picture(edges, elp);
}
return ellipses;
\end{lstlisting}
\caption{Поиск нескольких эллипсов}
\label{list:several_ellipses}
\end{ListingEnv}

\section{Результаты}
В процессе работы была создана программная реализация на языке \protect\cpp (использовался компилятор g++ версии 4.9.2). 
Для загрузки изображения, сохранения результатов, а также первичной обработки (выделения границ) использовалась библиотека OpenCV версии 3.0.

Для оценки работы программы использовались как синтетические, так и реальные изображения размеров 256x256, 512х512, 1024x1024 с различным количеством объектов для поиска и разной степенью зашумления.
Некоторые результаты приведены в таблице~\ref{tab:results}.

\begin{table}[H]
\centering
\caption{\label{tab:results}Некоторые результаты}
\begin{tabular}{ cc }
\toprule
  Исходное изображение & Результат \\
\midrule
  \fbox{\includegraphics[width=0.32\textwidth]{img/s20.jpg}} & \fbox{\includegraphics[width=0.32\textwidth]{img/s20r.jpg}} \\
  \fbox{\includegraphics[width=0.32\textwidth]{img/s18.jpg}} & \fbox{\includegraphics[width=0.32\textwidth]{img/s18r.jpg}} \\
  \fbox{\includegraphics[width=0.32\textwidth]{img/s29.jpg}} & \fbox{\includegraphics[width=0.32\textwidth]{img/s29r.jpg}} \\
\bottomrule
\end{tabular}
\end{table}

\section{Анализ алгоритма}
\subsection{Затраты по времени и памяти}
Иерархическая пирамида для входного изображения размера NxN будет иметь высоту \(log(N) - log(M) + 1\), где MxM - размер матрицы, стоящей в её вершине. 
При этом каждый уровень имеет размер в 4 раза меньше предыдущего. Размер такой структуры данных будет составлять \(N * N + \frac{N * N}{4} + \frac{N * N}{16} + ... < 2 * N^2\).
Такое же соотношение задаёт и количество операций, требуемых на её заполнение. В работе~\autocite{Chien} приводится оценка \(\Theta(N^2)\) для этого шага.


\subsection{Ограничения}

\Conc
В результате работы был разработан алгоритм поиска эллипсов на изображении, объединивший в себе две идеи, 
позволяющие существенно сократить время работы и уменьшить объем потребляемой памяти на больших изображениях.
Разработанный алгоритм был реализован и проверен на ряде синтетических и реальных изображений. 

% Печать списка литературы (библиографии)
\printbibliography[%{}
    heading=bibintoc%
]
% Файл со списком литературы: biblio.bib
% Подробно по оформлению библиографии:
% см. документацию к пакету biblatex-gost
% http://ctan.mirrorcatalogs.com/macros/latex/exptl/biblatex-contrib/biblatex-gost/doc/biblatex-gost.pdf
% и огромное количество примеров там же:
% http://mirror.macomnet.net/pub/CTAN/macros/latex/contrib/biblatex-contrib/biblatex-gost/doc/biblatex-gost-examples.pdf

\end{document}
